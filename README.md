# Microservices Architecture using ASP.Net Core 2, Docker, Masstransit, RabbitMQ, Elastic, and Kibana
This tutorial covers Microservices Architecture with an example implementation using ASP.Net Core 2, Docker, Masstransit, RabbitMQ, Elastic, and Kibana.

TODO: complete the tutorial document and the solution code

## 1. Microservices Design, Topology, and Best Practices
-
- 

### 1.1 Loose Coupling
- 
- 

### 1.2 Domain and Service Boundaries
- 
- 

### 1.3 Service Call Chain Optimization
- 
- 

### 1.4 Request/Response vs. Fire and Forget Services
- 
- 

## 2. Microservices Communication with Http, Protocol Buffers, and RabbitMQ
- 
- 

### 2.1 Using Http with Json and Gzip Compression
- 
- 

### 2.2 Using Http with Protocol Buffers
- 
- 

### 2.3 Using Queues
- 
- 

### 2.4 Service Bus with MassTransit
-
- 

## 3. Resiliency and Fault Tolerance
- 
- 

### 3.1 Transient Failures
- 
- 

### 3.2 Exponential Retry Policy with Polly
- 
- 

### 3.3 Circuit Breaker Pattern
- 
- 

### 3.4 Using Redis and RabbitMQ for Critical Operations
- 
- 

### 3.5 Load Balancing with RabbitMQ
- 
- 

## 4. Docker Containers, Docker Compose, and Kubernetes
- 
- 

### 4.1 Docker Containers
- 
- 

### 4.2 Docker Networking
- 
- 

### 4.3 Docker Compose and Service Discovery
- 
- 

### 4.4 Service Orchestration and Load Balancing with Kubernetes
- 
- 

## 5. Distributed Caching with Redis
- 
- 

### 5.1 In-process vs. Distributed Caching
- 
- 

### 5.2 Designing Document Structure for Redis
- 
- 

## 6. Centralized Logging and Correlation
- 
- 

### 6.1 Elastic, Kibana, and Logstash
- 
- 

### 6.2 Correlating Log Entries
- 
- 

## 7. Code Organization, Layering, and Clean Architecture
- 
- 

### 7.1 Feature Based Code Organization
- 
- 

### 7.2 Layers and Managing Dependencies
- 
- 

### 7.3 Clean Architecture
- 
- 

## 8. Organizing Business Logic with DDD and CQRS
- 
- 

### 8.1 CRUD
- 
- 

### 8.2 DDD
- 
- 

### 8.3 CQRS
- 
- 

## 9 Unit Testing and Integration Testing

### 9.1. Testable Code
- 
- 

### 9.2. Unit Testing Best Practices with NUnit and XUnit
- 
- 

### 9.3. Mocking using Moq
- 
- 

### 9.4 Integration Testing
- 
- 

### 9.5 Manual Testing and Documenting Apis with Swagger
- 
- 

## 10. Continuous Integration using Git, Bitbucket, Jenkins, and SonarQube
- 
- 

## 10.1 Continuous Integration Pipeline
- 
- 

## 10.2 Git Branching Strategies
- 
- 
## 10.3 Using Bitbucket and Code Reviews
- 
- 

## 10.4 Using Jenkins for Automated Builds and Deploymnt
- 
- 

## 10.5 Using SonarQube for Code Metrics Analysis
- 
- 

## 11. Example Solution Code
- 
- 

